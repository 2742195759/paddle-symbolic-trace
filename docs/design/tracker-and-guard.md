# Guard 传播机制

## 为什么需要 Guard？

在整个实现过程中，我们需要对用户函数的原始字节码转换成转换后的字节码，但如果每次运行都完整地转写全部字节码只会导致性能的浪费，也无法实现 JIT 的效果，因此我们需要一个缓存机制，来复用已经转换后的字节码。

但并不是说任何字节码成功转换一次后都是可以复用的，因为我们的字节码变换操作是通过模拟执行得到的，而模拟执行的起点是 Eval Frame 的初始状态，主要就是函数的输入，对于不同的输入，我们得到的字节码转换结果是可能不同的，因此我们需要有一个机制来判断转换后的字节码是否有效。

由于转换的过程与输入是强相关的，在函数 Eval Frame 初始阶段，我们可以从 `frame` 中拿到函数的输入，之后我们只需要通过 `guard` 来判断一个已经缓存的字节码是否有效即可，即 `guard(frame)`，如果结果是 `True`，则认为缓存命中。

guard 签名如下：

```python
Guard = Callable[[types.FrameType], bool]
```

## Guard 的传播

Guard

在模拟执行过程中，我们会根据字节码执行不同的操作，
